diff --git a/src/java/android/privacy/surrogate/PrivacyCDMALTEPhone.java b/src/java/android/privacy/surrogate/PrivacyCDMALTEPhone.java
new file mode 100644
index 0000000..f89f626
--- /dev/null
+++ b/src/java/android/privacy/surrogate/PrivacyCDMALTEPhone.java
@@ -0,0 +1,349 @@
+/**
+* Copyright (C) 2012 Stefan Thiele
+* This program is free software; you can redistribute it and/or modify it under
+* the terms of the GNU General Public License as published by the Free Software
+* Foundation; either version 3 of the License, or (at your option) any later version.
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY
+* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+* PARTICULAR PURPOSE. See the GNU General Public License for more details.
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, see <http://www.gnu.org/licenses>.
+*/
+
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.cdma.CdmaCellLocation;
+import android.util.Log;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.PhoneNotifier;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+import com.android.internal.telephony.cdma.CDMALTEPhone;
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev
+ * {@hide}
+ */
+public class PrivacyCDMALTEPhone extends CDMALTEPhone{
+
+	private static final String P_TAG = "PrivacyCDMALTEPhone";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	public PrivacyCDMALTEPhone(Context context, CommandsInterface cmdI, PhoneNotifier pN) {
+		super(context, cmdI, pN);
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		Log.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	public PrivacyCDMALTEPhone(Context context, CommandsInterface cmdI, PhoneNotifier pN, int phoneId) {
+		super(context, cmdI, pN, phoneId);
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		Log.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	@Override
+	public String getMsisdn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMsisdn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMsisdn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+//	public IsimRecords getIsimRecords() {
+//		return null;
+//	}
+	
+	@Override
+	public String getDeviceSvn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceSvn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceSvn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getImei() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getImei");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getImei();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getSubscriberId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        } else {
+            output = super.getSubscriberId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        }
+        return output;
+	}
+	
+//	@Override
+//	public void notifyLocationChanged() {
+//		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for notifyLocationChanged()");
+//		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+//		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+//			//do nothing here
+//		}
+//		else
+//			mNotifier.notifyCellLocation(this);
+//	}
+	
+	@Override
+	public String getLine1AlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1AlphaTag()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1AlphaTag();
+		}
+		return output;
+	}
+	
+	@Override
+	public String getVoiceMailAlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailAlphaTag()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailAlphaTag();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getVoiceMailNumber(){
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailNumber()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+
+	@Override
+	public String getDeviceId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getMeid() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMeid()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMeid();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getEsn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getEsn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getEsn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getLine1Number() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1Number()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1Number();
+		}
+		return output;
+	}
+	
+	@Override
+	public CellLocation getCellLocation() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getCellLocation()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && (settings.getLocationGpsSetting() != PrivacySettings.REAL || settings.getLocationNetworkSetting() != PrivacySettings.REAL)){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return new CdmaCellLocation();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL,PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getCellLocation();
+		}
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getPhoneSubInfo()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return null;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getPhoneSubInfo();
+		}
+	}
+	
+	@Override
+	public ServiceState getServiceState() {
+		try{
+			Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getServiceState()");
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				ServiceState output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				return output;
+			}
+			else{
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				return super.getServiceState();
+			}
+		}
+		catch(Exception e){
+			e.printStackTrace();
+			Log.e(P_TAG,"We got exception in getServiceState()-> give fake state");
+			ServiceState output = super.getServiceState();
+			output.setOperatorName("", "", "");
+			return output;
+		}
+	}
+	
+	private void checkDial() throws CallStateException {
+	    if (pSetMan != null) {
+	        PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		    if (settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL) {
+			    pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			    throw new CallStateException();
+		    }
+        	pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+		}
+	}
+
+//    @Override
+//    Connection dial(String dialString, UUSInfo uusInfo, int videoState, Bundle extras) throws CallStateException {
+//        checkDial();
+//        return super.dial(dialString, uusInfo, videoState, extras);
+//    }
+
+    @Override
+    public Connection dial(String dialString, UUSInfo uusInfo, int videoState) throws CallStateException {
+        checkDial();
+        return super.dial(dialString, uusInfo, videoState);
+    }
+
+    @Override
+    public Connection dial(String dialString, int videoState) throws CallStateException {
+        checkDial();
+        return super.dial(dialString, videoState);
+    }
+
+    @Override
+    public Connection dial(String dialString, int videoState, Bundle extras) throws CallStateException {
+        checkDial();
+        return super.dial(dialString, videoState, extras);
+    }
+}
diff --git a/src/java/android/privacy/surrogate/PrivacyCDMAPhone.java b/src/java/android/privacy/surrogate/PrivacyCDMAPhone.java
new file mode 100644
index 0000000..16b100c
--- /dev/null
+++ b/src/java/android/privacy/surrogate/PrivacyCDMAPhone.java
@@ -0,0 +1,322 @@
+/**
+* Copyright (C) 2012 Stefen Thiele
+* This program is free software; you can redistribute it and/or modify it under
+* the terms of the GNU General Public License as published by the Free Software
+* Foundation; either version 3 of the License, or (at your option) any later version.
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY
+* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+* PARTICULAR PURPOSE. See the GNU General Public License for more details.
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, see <http://www.gnu.org/licenses>.
+*/
+
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.cdma.CdmaCellLocation;
+import android.util.Log;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.PhoneNotifier;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+import com.android.internal.telephony.cdma.CDMAPhone;
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev
+ * {@hide}
+ */
+public class PrivacyCDMAPhone extends CDMAPhone{
+
+	private static final String P_TAG = "PrivacyCDMAPhone";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	public PrivacyCDMAPhone(Context context, CommandsInterface cmdI, PhoneNotifier pN) {
+		super(context,cmdI,pN);
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		Log.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	
+	@Override
+	public String getDeviceSvn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceSvn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceSvn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getImei() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getImei");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getImei();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getSubscriberId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        } else {
+            output = super.getSubscriberId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        }
+        return output;
+	}
+	
+//	@Override
+//	public void notifyLocationChanged() {
+//		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for notifyLocationChanged()");
+//		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+//		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+//			//do nothing here
+//		}
+//		else
+//			mNotifier.notifyCellLocation(this);
+//	}
+	
+	@Override
+	public String getLine1AlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1AlphaTag()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1AlphaTag();
+		}
+		return output;
+	}
+	
+	@Override
+	public String getVoiceMailAlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailAlphaTag()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailAlphaTag();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getVoiceMailNumber(){
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailNumber()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+
+	@Override
+	public String getDeviceId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getMeid() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMeid()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMeid();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getEsn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getEsn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getEsn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getLine1Number() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1Number()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1Number();
+		}
+		return output;
+	}
+	
+	@Override
+	public CellLocation getCellLocation() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getCellLocation()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && (settings.getLocationGpsSetting() != PrivacySettings.REAL || settings.getLocationNetworkSetting() != PrivacySettings.REAL)){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return new CdmaCellLocation();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL,PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getCellLocation();
+		}
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getPhoneSubInfo()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return null;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getPhoneSubInfo();
+		}
+	}
+	
+	@Override
+	public ServiceState getServiceState() {
+		try{
+			Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getServiceState()");
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				ServiceState output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				return output;
+			}
+			else{
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				return super.getServiceState();
+			}
+		}
+		catch(Exception e){
+			e.printStackTrace();
+			Log.e(P_TAG,"We got exception in getServiceState()-> give fake state");
+			ServiceState output = super.getServiceState();
+			output.setOperatorName("", "", "");
+			return output;
+		}
+	}
+	
+	private void checkDial() throws CallStateException {
+	    if (pSetMan != null) {
+	        PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		    if (settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL) {
+			    pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			    throw new CallStateException();
+		    }
+        	pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+		}
+	}
+
+//    @Override
+//    Connection dial(String dialString, UUSInfo uusInfo, int videoState, Bundle extras) throws CallStateException {
+//        checkDial();
+//        return super.dial(dialString, uusInfo, videoState, extras);
+//    }
+
+    @Override
+    public Connection dial(String dialString, UUSInfo uusInfo, int videoState) throws CallStateException {
+        checkDial();
+        return super.dial(dialString, uusInfo, videoState);
+    }
+
+    @Override
+    public Connection dial(String dialString, int videoState) throws CallStateException {
+        checkDial();
+        return super.dial(dialString, videoState);
+    }
+
+    @Override
+    public Connection dial(String dialString, int videoState, Bundle extras) throws CallStateException {
+        checkDial();
+        return super.dial(dialString, videoState, extras);
+    }
+}
diff --git a/src/java/android/privacy/surrogate/PrivacyGSMPhone.java b/src/java/android/privacy/surrogate/PrivacyGSMPhone.java
new file mode 100644
index 0000000..c137272
--- /dev/null
+++ b/src/java/android/privacy/surrogate/PrivacyGSMPhone.java
@@ -0,0 +1,323 @@
+/**
+* Copyright (C) 2012 Stefan Thiele
+* This program is free software; you can redistribute it and/or modify it under
+* the terms of the GNU General Public License as published by the Free Software
+* Foundation; either version 3 of the License, or (at your option) any later version.
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY
+* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+* PARTICULAR PURPOSE. See the GNU General Public License for more details.
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, see <http://www.gnu.org/licenses>.
+*/
+
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.gsm.GsmCellLocation;
+import android.util.Log;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.PhoneNotifier;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+import com.android.internal.telephony.gsm.GSMPhone;
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev
+ * {@hide}
+ */
+public class PrivacyGSMPhone extends GSMPhone{
+
+	private static final String P_TAG = "PrivacyGSMPhone";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	public PrivacyGSMPhone(Context context, CommandsInterface cmdI, PhoneNotifier pN, int phoneId) {
+		super(context,cmdI,pN, phoneId);
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		Log.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	@Override
+	public String getDeviceSvn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceSvn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceSvn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getImei() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getImei");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getImei();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getSubscriberId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        } else {
+            output = super.getSubscriberId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        }
+        return output;
+	}
+	
+
+//	@Override
+//	public void notifyLocationChanged() {
+//		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for notifyLocationChanged()");
+//		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+//		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+//			//do nothing here
+//		}
+//		else
+//			mNotifier.notifyCellLocation(this);
+//	}
+	
+	@Override
+	public String getLine1AlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1AlphaTag()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1AlphaTag();
+		}
+		return output;
+	}
+	
+	@Override
+	public String getVoiceMailAlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailAlphaTag()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailAlphaTag();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getVoiceMailNumber(){
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailNumber()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+
+	@Override
+	public String getDeviceId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getMeid() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMeid()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMeid();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getEsn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getEsn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getEsn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getLine1Number() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1Number()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1Number();
+		}
+		return output;
+	}
+	
+	@Override
+	public CellLocation getCellLocation() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getCellLocation()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && (settings.getLocationGpsSetting() != PrivacySettings.REAL || settings.getLocationNetworkSetting() != PrivacySettings.REAL)){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return new GsmCellLocation();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL,PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getCellLocation();
+		}
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getPhoneSubInfo()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return null;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getPhoneSubInfo();
+		}
+	}
+	
+	@Override
+	public ServiceState getServiceState() {
+		try{
+			Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getServiceState()");
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				ServiceState output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				return output;
+			}
+			else{
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				return super.getServiceState();
+			}
+		}
+		catch(Exception e){
+			e.printStackTrace();
+			Log.e(P_TAG,"We got exception in getServiceState()-> give fake state");
+			ServiceState output = super.getServiceState();
+			output.setOperatorName("", "", "");
+			return output;
+		}
+		
+	}
+	
+	private void checkDial() throws CallStateException {
+	    if (pSetMan != null) {
+	        PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		    if (settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL) {
+			    pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			    throw new CallStateException();
+		    }
+        	pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+		}
+	}
+
+    @Override
+    public Connection dial(String dialString, UUSInfo uusInfo, int videoState, Bundle extras) throws CallStateException {
+        checkDial();
+        return super.dial(dialString, uusInfo, videoState, extras);
+    }
+
+    @Override
+    public Connection dial(String dialString, UUSInfo uusInfo, int videoState) throws CallStateException {
+        checkDial();
+        return super.dial(dialString, uusInfo, videoState);
+    }
+
+    @Override
+    public Connection dial(String dialString, int videoState) throws CallStateException {
+        checkDial();
+        return super.dial(dialString, videoState);
+    }
+
+    @Override
+    public Connection dial(String dialString, int videoState, Bundle extras) throws CallStateException {
+        checkDial();
+        return super.dial(dialString, videoState, extras);
+    }
+}
diff --git a/src/java/android/privacy/surrogate/PrivacyPhoneProxy.java b/src/java/android/privacy/surrogate/PrivacyPhoneProxy.java
new file mode 100644
index 0000000..1f51c82
--- /dev/null
+++ b/src/java/android/privacy/surrogate/PrivacyPhoneProxy.java
@@ -0,0 +1,621 @@
+/**
+* Copyright (C) 2012 Stefan Thiele
+* This program is free software; you can redistribute it and/or modify it under
+* the terms of the GNU General Public License as published by the Free Software
+* Foundation; either version 3 of the License, or (at your option) any later version.
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY
+* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+* PARTICULAR PURPOSE. See the GNU General Public License for more details.
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, see <http://www.gnu.org/licenses>.
+*/
+
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.content.pm.IPackageManager;
+import android.os.Bundle;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.cdma.CdmaCellLocation;
+import android.telephony.gsm.GsmCellLocation;
+import android.util.Log;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneBase;
+import com.android.internal.telephony.PhoneProxy;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+
+import com.android.internal.telephony.PhoneConstants;
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev
+ * @deprecated normally this class is not neeeded anymore, since we got privacy phones. The only method which is interesting is getPhoneSubInfo 
+ * {@hide}
+ */
+
+public class PrivacyPhoneProxy extends PhoneProxy{
+
+	private static final String P_TAG = "PrivacyPhoneProxy";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	private boolean context_available;
+	
+	/** This PackageManager is needed to get package name if context is not available*/
+	private IPackageManager mPm;
+	
+	public PrivacyPhoneProxy(PhoneBase mPhone, Context context) { //not sure if context is available, so test it!
+		super(mPhone);
+		if(context != null){
+			this.context = context;
+			context_available = true;
+		}
+		else{
+			context_available = false;
+		}
+		initiate(context_available);
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		Log.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	/**
+	 * Method for initalize variables depends on context is availabe or not
+	 * @param ctx_av pass true, if context is available and false if not
+	 * {@hide}
+	 */
+	private void initiate(boolean ctx_av){
+		if(ctx_av){
+			Log.i(P_TAG,"Context is available for package:" + context.getPackageName());
+		} else{
+			Log.e(P_TAG,"Context is not available for package: " + context.getPackageName());
+			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+		}
+	}
+	
+	
+	/**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private String[] getPackageName(){
+    	try{
+    		if(mPm != null){
+        		int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+        	}
+    		else{
+    			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+    			int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+    		}
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(P_TAG,"something went wrong with getting package name");
+    		return null;
+    	}
+    }
+    
+
+    private void checkDial() throws CallStateException {
+        if (pSetMan == null) return;
+        String packageName;
+    	if (context_available) {
+    	    packageName = context.getPackageName();
+    	    checkDial(packageName);
+	    } else {
+    		String packageNames[] = getPackageName();
+		    if (packageNames == null) return;
+	        for (int i = 0; i < packageNames.length; i++) {
+	            packageName = packageNames[i];
+        	    checkDial(packageName);
+	        }
+	        packageName = packageNames[0];
+	    }
+       	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+	}
+
+    private void checkDial(String packageName) throws CallStateException {
+        PrivacySettings settings = pSetMan.getSettings(packageName, -1);
+        if (settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+            pSetMan.notification(packageName, 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+            throw new CallStateException();
+        }
+	}
+
+//    @Override
+//    public Connection dial(String dialString, UUSInfo uusInfo, int videoState, Bundle extras) throws CallStateException {
+//        checkDial();
+//        return super.dial(dialString, uusInfo, videoState, extras);
+//    }
+
+    @Override
+    public Connection dial(String dialString, UUSInfo uusInfo, int videoState) throws CallStateException {
+        checkDial();
+        return super.dial(dialString, uusInfo, videoState);
+    }
+
+    @Override
+    public Connection dial(String dialString, int videoState) throws CallStateException {
+        checkDial();
+        return super.dial(dialString, videoState);
+    }
+
+    @Override
+    public Connection dial(String dialString, int videoState, Bundle extras) throws CallStateException {
+        checkDial();
+        return super.dial(dialString, videoState, extras);
+    }
+
+
+	@Override
+	public CellLocation getCellLocation() {
+		int phone_type = super.getPhoneType();
+		if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && (settings.getLocationNetworkSetting() != PrivacySettings.REAL || settings.getLocationGpsSetting() != PrivacySettings.REAL)){
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getCellLocation()");
+				switch(phone_type){
+					case PhoneConstants.PHONE_TYPE_GSM:
+						return new GsmCellLocation();
+					case PhoneConstants.PHONE_TYPE_CDMA:
+						return new CdmaCellLocation();
+					case PhoneConstants.PHONE_TYPE_NONE:
+						return null;
+					case PhoneConstants.PHONE_TYPE_SIP:
+						return new CdmaCellLocation();
+					default: //just in case, but normally this doesn't get a call!
+						return new GsmCellLocation();
+				}
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getCellLocation()");
+				return super.getCellLocation();
+			}
+		}
+		else{ //context is not available, go through uid!
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.getCellLocation(); //we give cell location, because we can't get any package information in this process
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], Process.myUid());
+				if(pSetMan != null && settings != null && (settings.getLocationNetworkSetting() != PrivacySettings.REAL || settings.getLocationGpsSetting() != PrivacySettings.REAL)){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getCellLocation()");
+				return super.getCellLocation();
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getCellLocation()");
+				switch(phone_type){
+					case PhoneConstants.PHONE_TYPE_GSM:
+						return new GsmCellLocation();
+					case PhoneConstants.PHONE_TYPE_CDMA:
+						return new CdmaCellLocation();
+					case PhoneConstants.PHONE_TYPE_NONE:
+						return null;
+					case PhoneConstants.PHONE_TYPE_SIP:
+						return new CdmaCellLocation();
+					default: //just in case, but normally this doesn't get a call!
+						return new GsmCellLocation();
+				}
+			}
+		}
+	}
+	
+	@Override
+	public PhoneConstants.DataState getDataConnectionState() {
+		if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getDataConnection()");
+				return PhoneConstants.DataState.CONNECTING; //it's the best way to tell system that we are connecting
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getDataConnection()");
+				return super.getDataConnectionState();
+			}
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.getDataConnectionState();
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], Process.myUid());
+				if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getDataConnection()");
+				return super.getDataConnectionState();
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getDataConnection()");
+				return PhoneConstants.DataState.CONNECTING;
+			}
+		}
+	}
+	
+//	@Override
+//	public State getState() {
+//		State.
+//		return null;
+//	}
+	
+//	@Override
+//	public String getPhoneName() {
+//		return null;
+//	}
+	
+//	@Override
+//	public int getPhoneType() {
+//		return 0;
+//	}
+	
+	@Override
+	public SignalStrength getSignalStrength() {
+		SignalStrength output = new SignalStrength();
+		if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getSignalStrength()");
+				return output;
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getSignalStrength()");
+				return super.getSignalStrength();
+			}
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.getSignalStrength();
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], Process.myUid());
+				if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getSignalStrength()");
+				return super.getSignalStrength();
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getSignalStrength()");
+				return output;
+			}
+		}
+	}
+	
+//	@Override
+//	public IccCard getIccCard() {
+//		return null;
+//	}
+
+	@Override
+	public String getLine1Number() {
+	   if(context_available){
+		   String packageName = context.getPackageName();
+	       int uid = Process.myUid();
+	       PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+	       String output;
+	       if (pSet != null && pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+	           output = pSet.getLine1Number(); // can be empty, custom or random
+	           pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+	           Log.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getLine1Number()");
+	       } else {
+	           output = super.getLine1Number();
+	           pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+	           Log.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getLine1Number()");
+	       }
+	       return output;
+	   }
+	   else{
+		    String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			String output;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.getLine1Number();
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], Process.myUid());
+				if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				output = super.getLine1Number();
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], Process.myUid(), PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getLine1Number()");
+				return output;
+			}
+			else{
+				output = settings.getLine1Number();
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], Process.myUid(), settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getLine1Number()");
+				return output;
+			}
+	   }
+	}
+	
+	/**
+	 * Will be handled like the Line1Number.
+	 */
+	@Override
+	public String getLine1AlphaTag() {
+		return getLine1Number();
+	}
+	
+	/**
+	 * Will be handled like the Line1Number, since voice mailbox numbers often
+	 * are similar to the phone number of the subscriber.
+	 */
+	@Override
+	public String getVoiceMailNumber() {
+		return getLine1Number();
+	}
+	
+	//will look at this later!
+//	@Override
+//	public void getNeighboringCids(Message response) {
+//		
+//	}
+	
+	@Override
+	public String getDeviceId() {
+		if(context_available){
+			String packageName = context.getPackageName();
+	        int uid = Process.myUid();
+	        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+	        String output;
+	        if (pSet != null && pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+	            output = pSet.getDeviceId(); // can be empty, custom or random
+	            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+	            Log.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getDeviceId()");
+	        } else {
+	            output = super.getDeviceId();
+	            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+	            Log.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getDeviceId()");
+	        }
+	        return output;
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			String output;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.getDeviceId();
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], Process.myUid());
+				if(pSetMan != null && settings != null && settings.getDeviceIdSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				output = super.getDeviceId();
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], Process.myUid(), PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getDeviceId()");
+				return output;
+			}
+			else{
+				output = settings.getDeviceId();
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], Process.myUid(), settings.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getDeviceId()");
+				return output;
+			}
+	   }
+	}
+	
+	/**
+	 * Will be handled like the DeviceID.
+	 */
+	@Override
+	public String getDeviceSvn() {
+		return getDeviceId();
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		if(context_available){
+			String packageName = context.getPackageName();
+	        int uid = Process.myUid();
+	        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+	        String output;
+	        if (pSet != null && pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+	            output = pSet.getSubscriberId(); // can be empty, custom or random
+	            pSetMan.notification(packageName, uid, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);
+	            Log.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getSubscriberId()");
+	        } else {
+	            output = super.getSubscriberId();
+	            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);   
+	            Log.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getSubscriberId()");
+	        }
+	        return output;
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			String output;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.getSubscriberId();
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], Process.myUid());
+				if(pSetMan != null && settings != null && settings.getSubscriberIdSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				output = super.getSubscriberId();
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], Process.myUid(), PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, settings);      
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getSubscriberId()");
+				return output;
+			}
+			else{
+				output = settings.getSubscriberId();
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], Process.myUid(), settings.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getSubscriberId()");
+				return output;
+			}
+		}
+		
+	}
+	
+	/**
+	 * Will be handled like the SubscriberID.
+	 */
+	@Override
+	public String getIccSerialNumber() {
+		return getSubscriberId();
+	}
+	/**
+	 * Will be handled like the SubscriberID.
+	 */
+	@Override
+	public String getEsn() {
+		return getSubscriberId();
+	}
+	/**
+	 * Will be handled like the SubscriberID.
+	 */
+	@Override
+	public String getMeid() {
+		return getSubscriberId();
+	}
+	/**
+	 * Will be handled like the SubscriberID.
+	 */
+	@Override
+	public String getMsisdn() {
+		return getSubscriberId();
+	}
+	/**
+	 * Will be handled like the DeviceID.
+	 */
+	@Override
+	public String getImei() {
+		return getDeviceId();
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo(){
+		PhoneSubInfo output = new PhoneSubInfo(this);
+		return output;
+	}
+	
+	@Override
+	public ServiceState getServiceState(){
+		ServiceState output;
+		if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getServiceState()");
+				output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				//output.setRadioTechnology(-1);
+				return output;
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getServiceState()");
+				return super.getServiceState();
+			}
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.getServiceState();
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], Process.myUid());
+				if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getServiceState()");
+				return super.getServiceState();
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getServiceState()");
+				output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				return output;
+			}
+		}
+	}
+	
+	
+}
diff --git a/src/java/android/privacy/surrogate/PrivacySipPhone.java b/src/java/android/privacy/surrogate/PrivacySipPhone.java
new file mode 100644
index 0000000..a086dd5
--- /dev/null
+++ b/src/java/android/privacy/surrogate/PrivacySipPhone.java
@@ -0,0 +1,322 @@
+/**
+* Copyright (C) 2012 Stefan Thiele
+* This program is free software; you can redistribute it and/or modify it under
+* the terms of the GNU General Public License as published by the Free Software
+* Foundation; either version 3 of the License, or (at your option) any later version.
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY
+* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+* PARTICULAR PURPOSE. See the GNU General Public License for more details.
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, see <http://www.gnu.org/licenses>.
+*/
+
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.net.sip.SipProfile;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.gsm.GsmCellLocation;
+import android.util.Log;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.PhoneNotifier;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+import com.android.internal.telephony.sip.SipPhone;
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev
+ * {@hide}
+ */
+public class PrivacySipPhone extends SipPhone{
+
+	private static final String P_TAG = "PrivacySipPhone";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	public PrivacySipPhone(Context context, PhoneNotifier pN, SipProfile sP) {
+		super(context, pN, sP); //I've changed the constructor to public!
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		Log.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	@Override
+	public String getDeviceSvn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceSvn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getImei() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getImei");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getImei();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getSubscriberId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        } else {
+            output = super.getSubscriberId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        }
+        return output;
+	}
+	
+
+//	void notifyLocationChanged() {
+//		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for notifyLocationChanged()");
+//		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+//		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+//			//do nothing here
+//		}
+//		else
+//			mNotifier.notifyCellLocation(this);
+//	}
+	
+	@Override
+	public String getLine1AlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1AlphaTag()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1AlphaTag();
+		}
+		return output;
+	}
+	
+	@Override
+	public String getVoiceMailAlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailAlphaTag()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailAlphaTag();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getVoiceMailNumber(){
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailNumber()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+
+	@Override
+	public String getDeviceId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getMeid() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMeid()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMeid();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getEsn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getEsn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getEsn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getLine1Number() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1Number()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1Number();
+		}
+		return output;
+	}
+	
+	@Override
+	public CellLocation getCellLocation() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getCellLocation()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && (settings.getLocationGpsSetting() != PrivacySettings.REAL || settings.getLocationNetworkSetting() != PrivacySettings.REAL)){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return new GsmCellLocation();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL,PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getCellLocation();
+		}
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getPhoneSubInfo()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return null;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getPhoneSubInfo();
+		}
+	}
+	
+	@Override
+	public ServiceState getServiceState() {
+		try{
+			Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getServiceState()");
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				ServiceState output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				return output;
+			}
+			else{
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				return super.getServiceState();
+			}
+		}
+		catch(Exception e){
+			e.printStackTrace();
+			Log.e(P_TAG,"We got exception in getServiceState()-> give fake state");
+			ServiceState output = super.getServiceState();
+			output.setOperatorName("", "", "");
+			return output;
+		}
+		
+	}
+	
+	private void checkDial() throws CallStateException {
+	    if (pSetMan != null) {
+	        PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		    if (settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL) {
+			    pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			    throw new CallStateException();
+		    }
+        	pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+		}
+	}
+
+//    @Override
+//    Connection dial(String dialString, UUSInfo uusInfo, int videoState, Bundle extras) throws CallStateException {
+//        checkDial();
+//        return super.dial(dialString, uusInfo, videoState, extras);
+//    }
+
+    @Override
+    public Connection dial(String dialString, UUSInfo uusInfo, int videoState) throws CallStateException {
+        checkDial();
+        return super.dial(dialString, uusInfo, videoState);
+    }
+
+    @Override
+    public Connection dial(String dialString, int videoState) throws CallStateException {
+        checkDial();
+        return super.dial(dialString, videoState);
+    }
+
+    @Override
+    public Connection dial(String dialString, int videoState, Bundle extras) throws CallStateException {
+        checkDial();
+        return super.dial(dialString, videoState, extras);
+    }
+}
diff --git a/src/java/com/android/internal/telephony/IccSmsInterfaceManager.java b/src/java/com/android/internal/telephony/IccSmsInterfaceManager.java
index 2e9c17e..8588b83 100644
--- a/src/java/com/android/internal/telephony/IccSmsInterfaceManager.java
+++ b/src/java/com/android/internal/telephony/IccSmsInterfaceManager.java
@@ -16,6 +16,15 @@
 
 package com.android.internal.telephony;
 
+// BEGIN privacy additions
+import android.content.pm.PackageManager;
+import android.os.Binder;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+// END privacy
+
 import android.Manifest;
 import android.app.AppOpsManager;
 import android.app.PendingIntent;
@@ -85,6 +94,119 @@ public class IccSmsInterfaceManager {
     final private UserManager mUserManager;
     protected SMSDispatcher mDispatcher;
 
+    // BEGIN privacy additions
+
+    protected PrivacySettingsManager pSetMan;
+
+    protected static final String P_TAG = "PrivacySMSInterfaceManager";
+
+    protected static final int ACCESS_TYPE_SMS_MMS = 0;
+    protected static final int ACCESS_TYPE_ICC = 1;
+
+    /**
+     * Gives the actual package names which are trying to send sms
+     * {@hide}
+     * @return package name array or null
+     */
+   protected String[] getPackageName(){
+        PackageManager pm = mContext.getPackageManager();
+        String[] packageNames = pm.getPackagesForUid(Binder.getCallingUid());
+        return packageNames;
+   }
+
+    /**
+     * This method also includes notifications!
+     * @param packageNames 
+     * @param accessType use constants ACCESS_TYPE_SMS_MMS and ACCESS_TYPE_ICC
+     * @return true if package is allowed or exception was thrown or packages are empty, false if package is not allowed 
+     * {@hide}
+     */
+    protected boolean isAllowed(String[] packageNames, int accessType){
+       try{
+           switch(accessType){
+               case ACCESS_TYPE_SMS_MMS:
+                   PrivacySettings settings = null;
+                   if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+                   if(pSetMan != null && packageNames != null){
+                       for(int i=0; i < packageNames.length; i++){
+                           settings = pSetMan.getSettings(packageNames[i], -1);
+                           if(pSetMan != null && settings != null && settings.getSmsSendSetting() != PrivacySettings.REAL){
+                               notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+
+                               return false;
+                           }
+                           settings = null;
+                       }
+                       notify(accessType, packageNames[0],PrivacySettings.REAL);
+
+                       return true;
+                   }
+                   else{
+                       if(packageNames != null && packageNames.length > 0)
+                           notify(accessType, packageNames[0],PrivacySettings.REAL);
+
+                           return true;
+                   }
+               case ACCESS_TYPE_ICC:
+                   if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+                   if(pSetMan != null && packageNames != null){
+                       for(int i=0; i < packageNames.length; i++){
+                           settings = pSetMan.getSettings(packageNames[i], -1);
+                           if(pSetMan != null && settings != null && settings.getIccAccessSetting() != PrivacySettings.REAL){
+                               notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+                               return false;
+                           }
+                           settings = null;
+                       }
+                       notify(accessType, packageNames[0],PrivacySettings.REAL);
+                       return true;
+                   }
+                   else{
+                       if(packageNames != null && packageNames.length > 0)
+                           notify(accessType, packageNames[0],PrivacySettings.REAL);
+
+                       return true;
+                   }
+               default:
+                   notify(accessType, packageNames[0],PrivacySettings.REAL);
+                   return true;
+           }
+
+       }
+       catch(Exception e){
+           Log.e(P_TAG,"Got exception while checking for sms or ICC acess permission");
+           e.printStackTrace();
+           if(packageNames != null && pSetMan != null && packageNames.length > 0){
+               PrivacySettings settings = pSetMan.getSettings(packageNames[0], -1);
+               if(settings != null)
+                   notify(accessType, packageNames[0],PrivacySettings.REAL);
+           }
+           return true;
+       }
+    }
+
+    /**
+     * {@hide}
+     * Helper method for method isAllowed() to show dataAccess toasts
+     * @param accessType use ACCESS_TYPE_SMS_MMS or ACCESS_TYPE_ICC
+     * @param packageName the package name
+     * @param accessMode PrivacySettings.REAL || PrivacySettings.CUSTOM || PrivacySettings.RANDOM || PrivacySettings.EMPTY
+     */
+    protected void notify(int accessType,String packageName, byte accessMode){
+       switch(accessType){
+           case ACCESS_TYPE_SMS_MMS:
+               //Log.i("PrivacySmsManager","now send notify information outgoing sms");
+               pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_SMS_SEND, null, null);
+               break;
+           case ACCESS_TYPE_ICC:
+               //Log.i("PrivacySmsManager","now send notify information ICC ACCESS");
+               pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_ICC_ACCESS, null, null);
+               break;
+       }
+    }
+
+    // END privacy
+
     protected Handler mHandler = new Handler() {
         @Override
         public void handleMessage(Message msg) {
@@ -198,6 +320,11 @@ public class IccSmsInterfaceManager {
         if (DBG) log("updateMessageOnIccEf: index=" + index +
                 " status=" + status + " ==> " +
                 "("+ Arrays.toString(pdu) + ")");
+        // BEGIN privacy additions
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return false;
+        }
+        // END privacy
         enforceReceiveAndSend("Updating message on Icc");
         if (mAppOps.noteOp(AppOpsManager.OP_WRITE_ICC_SMS, Binder.getCallingUid(),
                 callingPackage) != AppOpsManager.MODE_ALLOWED) {
@@ -252,6 +379,11 @@ public class IccSmsInterfaceManager {
         if (DBG) log("copyMessageToIccEf: status=" + status + " ==> " +
                 "pdu=("+ Arrays.toString(pdu) +
                 "), smsc=(" + Arrays.toString(smsc) +")");
+        // BEGIN privacy additions
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return false;
+        }
+        // END privacy
         enforceReceiveAndSend("Copying message to Icc");
         if (mAppOps.noteOp(AppOpsManager.OP_WRITE_ICC_SMS, Binder.getCallingUid(),
                 callingPackage) != AppOpsManager.MODE_ALLOWED) {
@@ -285,6 +417,12 @@ public class IccSmsInterfaceManager {
     /**
      * Retrieves all messages currently stored on Icc.
      *
+        // BEGIN privacy
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return new ArrayList<SmsRawData>();
+        }
+        // END privacy
+
      * @return list of SmsRawData of all sms on Icc
      */
 
diff --git a/src/java/com/android/internal/telephony/PhoneFactory.java b/src/java/com/android/internal/telephony/PhoneFactory.java
index 174a8b4..16a6ed9 100644
--- a/src/java/com/android/internal/telephony/PhoneFactory.java
+++ b/src/java/com/android/internal/telephony/PhoneFactory.java
@@ -18,6 +18,19 @@ package com.android.internal.telephony;
 
 import static com.android.internal.telephony.TelephonyProperties.PROPERTY_DEFAULT_SUBSCRIPTION;
 
+//BEGIN PRIVACY ADDED
+//--------------------------------------------------------
+//import com.android.internal.telephony.cdma.CDMAPhone;
+//import com.android.internal.telephony.cdma.CDMALTEPhone;
+//import com.android.internal.telephony.gsm.GSMPhone;
+import android.privacy.surrogate.PrivacyCDMAPhone;
+import android.privacy.surrogate.PrivacyCDMALTEPhone;
+import android.privacy.surrogate.PrivacyGSMPhone;
+import android.privacy.surrogate.PrivacySipPhone;
+import android.privacy.surrogate.PrivacyPhoneProxy;
+//--------------------------------------------------------
+//END PRIVACY ADDED
+
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
@@ -194,15 +207,26 @@ public class PhoneFactory {
                     PhoneBase phone = null;
                     int phoneType = TelephonyManager.getPhoneType(networkModes[i]);
                     if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
-                        phone = new GSMPhone(context,
+                        //BEGIN PRIVACY ADDED
+                        //phone = new GSMPhone(context,
+                        //        sCommandsInterfaces[i], sPhoneNotifier, i);
+                        phone = new PrivacyGSMPhone(context,
                                 sCommandsInterfaces[i], sPhoneNotifier, i);
+                        //END PRIVACY ADDED
                     } else if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
-                        phone = new CDMALTEPhone(context,
+                        //BEGIN PRIVACY ADDED
+                        //phone = new CDMALTEPhone(context,
+                        //        sCommandsInterfaces[i], sPhoneNotifier, i);
+                        phone = new PrivacyCDMALTEPhone(context,
                                 sCommandsInterfaces[i], sPhoneNotifier, i);
+                        //END PRIVACY ADDED
                     }
                     Rlog.i(LOG_TAG, "Creating Phone with type = " + phoneType + " sub = " + i);
 
-                    sProxyPhones[i] = new PhoneProxy(phone);
+                    //BEGIN PRIVACY ADDED
+                    //sProxyPhones[i] = new PhoneProxy(phone);
+                    sProxyPhones[i] = new PrivacyPhoneProxy(phone, context);
+                    //END PRIVACY ADDED
                 }
                 mProxyController = ProxyController.getInstance(context, sProxyPhones,
                         mUiccController, sCommandsInterfaces);
@@ -247,7 +271,7 @@ public class PhoneFactory {
 
     public static Phone getGsmPhone(int phoneId) {
         synchronized(PhoneProxy.lockForRadioTechnologyChange) {
-            Phone phone = new GSMPhone(sContext, sCommandsInterfaces[phoneId],
+            Phone phone = new PrivacyGSMPhone(sContext, sCommandsInterfaces[phoneId],
                     sPhoneNotifier, phoneId);
             return phone;
         }
@@ -307,13 +331,19 @@ public class PhoneFactory {
         synchronized(PhoneProxy.lockForRadioTechnologyChange) {
             switch (TelephonyManager.getLteOnCdmaModeStatic()) {
                 case PhoneConstants.LTE_ON_CDMA_TRUE: {
-                    phone = new CDMALTEPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    //BEGIN PRIVACY ADDED
+                    //phone = new CDMALTEPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    phone = new PrivacyCDMALTEPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    //END PRIVACY ADDED
                     break;
                 }
                 case PhoneConstants.LTE_ON_CDMA_FALSE:
                 case PhoneConstants.LTE_ON_CDMA_UNKNOWN:
                 default: {
-                    phone = new CDMAPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    //BEGIN PRIVACY ADDED
+                    //phone = new CDMAPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    phone = new PrivacyCDMAPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    //END PRIVACY ADDED
                     break;
                 }
             }
diff --git a/src/java/com/android/internal/telephony/SMSDispatcher.java b/src/java/com/android/internal/telephony/SMSDispatcher.java
index 90d0751..6d47116 100644
--- a/src/java/com/android/internal/telephony/SMSDispatcher.java
+++ b/src/java/com/android/internal/telephony/SMSDispatcher.java
@@ -76,6 +76,13 @@ import java.util.Random;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
+// BEGIN PRIVACY ADDED
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+// END PRIVACY ADDED
+
 import static android.telephony.SmsManager.RESULT_ERROR_FDN_CHECK_FAILURE;
 import static android.telephony.SmsManager.RESULT_ERROR_GENERIC_FAILURE;
 import static android.telephony.SmsManager.RESULT_ERROR_LIMIT_EXCEEDED;
@@ -178,6 +185,123 @@ public abstract class SMSDispatcher extends Handler {
         sConcatenatedRef += 1;
         return sConcatenatedRef;
     }
+    
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+    protected PrivacySettingsManager pSetMan;
+    
+    protected static final String P_TAG = "PrivacySMSDispatcher";
+    
+    protected static final int ACCESS_TYPE_SMS_MMS = 0;
+	protected static final int ACCESS_TYPE_ICC = 1;
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    /**
+     * Gives the actual package names which are trying to send sms
+     * {@hide}
+     * @return package name array or null
+     */
+	protected String[] getPackageName(){
+		 PackageManager pm = mContext.getPackageManager();
+	     String[] packageNames = pm.getPackagesForUid(Binder.getCallingUid());
+	     return packageNames;
+	}
+    
+    /**
+     * This method also includes notifications!
+     * @param packageNames 
+     * @param accessType use constants ACCESS_TYPE_SMS_MMS and ACCESS_TYPE_ICC
+     * @return true if package is allowed or exception was thrown or packages are empty, false if package is not allowed 
+     * {@hide}
+     */
+    protected boolean isAllowed(String[] packageNames, int accessType){
+    	try{
+    		switch(accessType){
+    			case ACCESS_TYPE_SMS_MMS:
+    				PrivacySettings settings = null;
+    	        	if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i], -1);
+    	            		if(pSetMan != null && settings != null && settings.getSmsSendSetting() != PrivacySettings.REAL){
+    	            			notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        		
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		if(packageNames != null && packageNames.length > 0)
+    	        			notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	     
+    	        		return true;
+    	        	}
+    			case ACCESS_TYPE_ICC:
+    				if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i], -1);
+    	            		if(pSetMan != null && settings != null && settings.getIccAccessSetting() != PrivacySettings.REAL){
+    	            			notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		if(packageNames != null && packageNames.length > 0)
+    	        			notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        			
+    	        		return true;
+    	        	}
+    	        default:
+    	        	notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        	return true;
+    		}
+    	}
+    	catch(Exception e){
+    		Rlog.e(P_TAG,"Got exception while checking for sms or ICC acess permission");
+    		e.printStackTrace();
+    		if(packageNames != null && pSetMan != null && packageNames.length > 0){
+    			PrivacySettings settings = pSetMan.getSettings(packageNames[0], -1);
+    			if(settings != null)
+    				notify(accessType, packageNames[0],PrivacySettings.REAL);
+    		}
+    		return true;
+    	}
+    }
+    
+    /**
+     * {@hide}
+     * Helper method for method isAllowed() to show dataAccess toasts
+     * @param accessType use ACCESS_TYPE_SMS_MMS or ACCESS_TYPE_ICC
+     * @param packageName the package name
+     * @param accessMode PrivacySettings.REAL || PrivacySettings.CUSTOM || PrivacySettings.RANDOM || PrivacySettings.EMPTY
+     */
+    protected void notify(int accessType,String packageName, byte accessMode){
+    	switch(accessType){
+    		case ACCESS_TYPE_SMS_MMS:
+    			//Rlog.i("PrivacySmsManager","now send notify information outgoing sms");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_SMS_SEND, null, null);
+    			break;
+    		case ACCESS_TYPE_ICC:
+    			//Rlog.i("PrivacySmsManager","now send notify information ICC ACCESS");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_ICC_ACCESS, null, null);
+    			break;
+    	}
+    }
+    
+    // END privacy
+    
 
     /**
      * Create a new SMS dispatcher.
@@ -196,7 +320,11 @@ public abstract class SMSDispatcher extends Handler {
         mSettingsObserver = new SettingsObserver(this, mPremiumSmsRule, mContext);
         mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(
                 Settings.Global.SMS_SHORT_CODE_RULE), false, mSettingsObserver);
-
+        // BEGIN privacy
+        // -------------------------------------------------------------------------------
+        if(pSetMan == null) new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+        // -------------------------------------------------------------------------------
+        // ENDprivacy
         mSmsCapable = mContext.getResources().getBoolean(
                 com.android.internal.R.bool.config_sms_capable);
         mSmsSendDisabled = !SystemProperties.getBoolean(
@@ -205,7 +333,7 @@ public abstract class SMSDispatcher extends Handler {
         Rlog.d(TAG, "SMSDispatcher: ctor mSmsCapable=" + mSmsCapable + " format=" + getFormat()
                 + " mSmsSendDisabled=" + mSmsSendDisabled);
     }
-
+        
     /**
      * Observe the secure setting for updated premium sms determination rules
      */
@@ -841,8 +969,23 @@ public abstract class SMSDispatcher extends Handler {
             tracker.onFailed(mContext, RESULT_ERROR_NULL_PDU, 0/*errorCode*/);
             return;
         }
-        
+
+
         PendingIntent sentIntent = tracker.mSentIntent;
+
+        // BEGIN Privacy
+        if (!isAllowed(getPackageName(), ACCESS_TYPE_SMS_MMS)) {
+            if (sentIntent != null) {
+                try {
+                    sentIntent.send(RESULT_ERROR_GENERIC_FAILURE);
+                    Rlog.i(TAG,"fake also delivery state to radio off!");
+                } catch (CanceledException e) {}
+            }
+            return;
+        }
+        // END privacy
+
+
         // Get calling app package name via UID from Binder call
         PackageManager pm = mContext.getPackageManager();
         int callingUid = Binder.getCallingUid();
diff --git a/src/java/com/android/internal/telephony/cdma/CDMAPhone.java b/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
old mode 100644
new mode 100755
index 4cc182b..ef4beba
--- a/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
+++ b/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
@@ -1122,7 +1122,7 @@ public class CDMAPhone extends PhoneBase {
          super.notifyServiceStateChangedP(ss);
      }
 
-     void notifyLocationChanged() {
+     public void notifyLocationChanged() {
          mNotifier.notifyCellLocation(this);
      }
 
diff --git a/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java b/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
index 7bb56cb..b7ef587 100644
--- a/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
@@ -72,6 +72,15 @@ import java.util.Date;
 import java.util.List;
 import java.util.TimeZone;
 
+/////////////////////////////////////////////////////////
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import java.util.Random;
+/////////////////////////////////////////////////////////
+
+
 /**
  * {@hide}
  */
@@ -126,6 +135,11 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
     String mSavedTimeZone;
     long mSavedTime;
     long mSavedAtTime;
+    
+    //-------------------------------------------------------------------------------------------------------------------------------------------------
+    private Context mContext;
+    private PrivacySettingsManager pSetMan;
+    //-------------------------------------------------------------------------------------------------------------------------------------------------
 
     /** Wake lock used while setting time of day. */
     private PowerManager.WakeLock mWakeLock;
@@ -219,6 +233,11 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
 
         mHbpcdUtils = new HbpcdUtils(phone.getContext());
 
+        //-------------------------------------------------------------------------------------------------------------------------------------------------
+        this.mContext = phone.getContext();
+        pSetMan = new PrivacySettingsManager(mContext, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+        //-------------------------------------------------------------------------------------------------------------------------------------------------
+
         // Reset OTASP state in case previously set by another service
         phone.notifyOtaspChanged(OTASP_UNINITIALIZED);
     }
@@ -399,11 +418,22 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
                     }
                 }
 
-                mCellLoc.setCellLocationData(baseStationId, baseStationLatitude,
-                        baseStationLongitude, systemId, networkId);
-                mPhone.notifyLocationChanged();
-            }
-
+                // BEGIN privacy additions
+                PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName(), 0);
+                if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.EMPTY){
+                	//we will update with invalid cell location values
+                	mCellLoc.setStateInvalid();
+                }
+                else if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.RANDOM){
+                	Random values = new Random();
+                	mCellLoc.setCellLocationData(values.nextInt(), values.nextInt(), values.nextInt(), values.nextInt(), values.nextInt());
+                }
+                else{
+                	mCellLoc.setCellLocationData(baseStationId, baseStationLatitude, baseStationLongitude, systemId, networkId);
+                }
+                 mPhone.notifyLocationChanged();
+                // END privacy
+             }
             // Release any temporary cell lock, which could have been
             // acquired to allow a single-shot location update.
             disableSingleLocationUpdate();
@@ -670,6 +700,7 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
     protected void handlePollStateResultMessage(int what, AsyncResult ar){
         int ints[];
         String states[];
+  	PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName(), 0);
         switch (what) {
             case EVENT_POLL_STATE_GPRS:
                 states = (String[])ar.result;
@@ -794,8 +825,19 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
 
 
                 // Values are -1 if not available.
-                mNewCellLoc.setCellLocationData(baseStationId, baseStationLatitude,
-                        baseStationLongitude, systemId, networkId);
+             // BEGIN privacy additions
+             if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.EMPTY){
+                 //we will update with invalid cell location and station values
+                 mNewCellLoc.setStateInvalid();
+             }
+             else if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.RANDOM){
+                 Random values = new Random();
+                 mNewCellLoc.setCellLocationData(values.nextInt(), values.nextInt(), values.nextInt(), values.nextInt(), values.nextInt());
+             }
+             else{
+                 mNewCellLoc.setCellLocationData(baseStationId, baseStationLatitude, baseStationLongitude, systemId, networkId);
+             }
+             //END privacy
 
                 if (reasonForDenial == 0) {
                     mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
@@ -828,25 +870,37 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
                         }
                     }
 
+                    // BEGIN privacy additions
                     if (!mIsSubscriptionFromRuim) {
                         // In CDMA in case on NV, the ss.mOperatorAlphaLong is set later with the
                         // ERI text, so here it is ignored what is coming from the modem.
-                        mNewSS.setOperatorName(null, opNames[1], opNames[2]);
+                        if (pSetMan != null && settings != null 
+                                && settings.getNetworkInfoSetting() != PrivacySettings.REAL) {
+                            mNewSS.setOperatorName(null, "", "");
+                        } else {
+                            mNewSS.setOperatorName(null, opNames[1], opNames[2]);
+                        }
                     } else {
-                        String brandOverride = mUiccController.getUiccCard() != null ?
-                            mUiccController.getUiccCard().getOperatorBrandOverride() : null;
-                        if (brandOverride != null) {
-                            mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
-                        } else if (SystemProperties.getBoolean("ro.cdma.force_plmn_lookup",
-                                false)) {
-                            mNewSS.setOperatorName(
-                                Operators.operatorReplace(opNames[2]),
-                                opNames[1],
-                                opNames[2]);
+                        if (pSetMan != null && settings != null
+                                && settings.getNetworkInfoSetting() != PrivacySettings.REAL) {
+                            mNewSS.setOperatorName("", "", "");
                         } else {
-                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
+                            String brandOverride = mUiccController.getUiccCard() != null ?
+                                mUiccController.getUiccCard().getOperatorBrandOverride() : null;
+                            if (brandOverride != null) {
+                                mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
+                            } else if (SystemProperties.getBoolean("ro.cdma.force_plmn_lookup",
+                                    false)) {
+                                mNewSS.setOperatorName(
+                                    Operators.operatorReplace(opNames[2]),
+                                    opNames[1],
+                                    opNames[2]);
+                            } else {
+                                mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
+                            }
                         }
                     }
+                    // END privacy
                 } else {
                     if (DBG) log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
                 }
@@ -1199,13 +1253,27 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
             if ((mCi.getRadioState().isOn()) && (!mIsSubscriptionFromRuim)) {
                 String eriText;
                 // Now the CDMAPhone sees the new ServiceState so it can get the new ERI text
-                if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
-                    eriText = mPhone.getCdmaEriText();
-                } else {
-                    // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
-                    // mRegistrationState 0,2,3 and 4
-                    eriText = mPhone.getContext().getText(
-                            com.android.internal.R.string.roamingTextSearching).toString();
+                // BEGIN privacy additions
+                PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName(), 0);
+                if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+                    if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
+                        eriText = "";
+                    } else {
+                        // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
+                        // mRegistrationState 0,2,3 and 4
+                        eriText = mPhone.getContext().getText(
+                                com.android.internal.R.string.roamingTextSearching).toString();
+                    }
+                } else{
+                    //original code
+                    if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
+                        eriText = mPhone.getCdmaEriText();
+                    } else {
+                        // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
+                        // mRegistrationState 0,2,3 and 4
+                        eriText = mPhone.getContext().getText(
+                                com.android.internal.R.string.roamingTextSearching).toString();
+                    }
                 }
                 mSS.setOperatorAlphaLong(eriText);
             }
diff --git a/src/java/com/android/internal/telephony/gsm/GSMPhone.java b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
index 9d9535a..3e711da 100644
--- a/src/java/com/android/internal/telephony/gsm/GSMPhone.java
+++ b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
@@ -466,7 +466,7 @@ public class GSMPhone extends PhoneBase {
      * Notify any interested party of a Phone state change
      * {@link com.android.internal.telephony.PhoneConstants.State}
      */
-    /*package*/ void notifyPhoneStateChanged() {
+    /*package*/ public void notifyPhoneStateChanged() {
         mNotifier.notifyPhoneState(this);
     }
 
@@ -505,7 +505,7 @@ public class GSMPhone extends PhoneBase {
     }
 
     /*package*/
-    void notifyLocationChanged() {
+    public void notifyLocationChanged() {
         mNotifier.notifyCellLocation(this);
     }
 
diff --git a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
index 65c2dd9..4416790 100644
--- a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
@@ -85,6 +85,14 @@ import java.util.Date;
 import java.util.List;
 import java.util.TimeZone;
 
+//////////////////////////////////////////////////////////
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import java.util.Random;
+//////////////////////////////////////////////////////////
+
 /**
  * {@hide}
  */
@@ -98,6 +106,11 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
     GsmCellLocation mNewCellLoc;
     int mPreferredNetworkType;
 
+    // BEGIN privacy additions
+    private Context mContext;
+    private PrivacySettingsManager pSetMan;
+    // END privacy
+
     private int mMaxDataCalls = 1;
     private int mNewMaxDataCalls = 1;
     private int mReasonDataDenied = -1;
@@ -251,6 +264,12 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
         Context context = phone.getContext();
         filter.addAction(ACTION_RADIO_OFF);
         context.registerReceiver(mIntentReceiver, filter);
+
+        //--------------------------------------------------------------------------
+        this.mContext = phone.getContext();
+        pSetMan = new PrivacySettingsManager(mContext, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+        //--------------------------------------------------------------------------
+
     }
 
     @Override
@@ -362,8 +381,23 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
                             Rlog.w(LOG_TAG, "error parsing location: " + ex);
                         }
                     }
-                    mCellLoc.setLacAndCid(lac, cid);
-                    mPhone.notifyLocationChanged();
+                    // BEGIN privacy additions
+                    PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName(), 0);
+                    if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.EMPTY){
+                    	//we will update with invalid cell location values
+                    	mCellLoc.setStateInvalid();
+                    	mPhone.notifyLocationChanged();
+                    }
+                    else if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.RANDOM){
+                    	Random values = new Random();
+                    	mCellLoc.setLacAndCid(values.nextInt(), values.nextInt());
+                        mPhone.notifyLocationChanged();
+                    }
+                    else{
+                    	mCellLoc.setLacAndCid(lac, cid);
+                        mPhone.notifyLocationChanged();
+                    }
+                     // END privacy
                 }
 
                 // Release any temporary cell lock, which could have been
@@ -702,6 +736,7 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
                         ar.exception);
             }
         } else try {
+        	PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName(), 0);
             switch (what) {
                 case EVENT_POLL_STATE_REGISTRATION: {
                     states = (String[])ar.result;
@@ -779,8 +814,22 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
                     }
 
                     // LAC and CID are -1 if not avail
-                    mNewCellLoc.setLacAndCid(lac, cid);
-                    mNewCellLoc.setPsc(psc);
+                    // BEGIN privacy additions
+                    if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.EMPTY){
+                    	//we will update with invalid cell location values
+                    	mNewCellLoc.setStateInvalid();
+                        mNewCellLoc.setPsc(psc);
+                    }
+                    else if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.RANDOM){
+                    	Random values = new Random();
+                    	mNewCellLoc.setLacAndCid(values.nextInt(), values.nextInt());
+                        mNewCellLoc.setPsc(psc);
+                    }
+                    else{
+                    	mNewCellLoc.setLacAndCid(lac, cid);
+                        mNewCellLoc.setPsc(psc);
+                    }
+                    // END privacy
                     break;
                 }
 
@@ -826,13 +875,20 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
                     String opNames[] = (String[])ar.result;
 
                     if (opNames != null && opNames.length >= 3) {
-                        String brandOverride = mUiccController.getUiccCard() != null ?
-                            mUiccController.getUiccCard().getOperatorBrandOverride() : null;
-                        if (brandOverride != null) {
-                            mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
-                        } else {
-                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
+                        // BEGIN privacy additions
+                        if (pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL) {
+                            mNewSS.setOperatorName ("", "", "");
+                        }
+                        else{
+                            String brandOverride = mUiccController.getUiccCard() != null ?
+                                mUiccController.getUiccCard().getOperatorBrandOverride() : null;
+                            if (brandOverride != null) {
+                                mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
+                            } else {
+                                mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
+                            }
                         }
+                        // END privacy
                     }
                     break;
                 }
@@ -1283,7 +1339,7 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
         }
 
         if (hasLocationChanged) {
-            mPhone.notifyLocationChanged();
+            mPhone.notifyLocationChanged(); //we can notify, because all sensitive data has changed before @author CollegeDev
         }
 
         if (! isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
diff --git a/src/java/com/android/internal/telephony/sip/SipPhone.java b/src/java/com/android/internal/telephony/sip/SipPhone.java
index 279ead6..5972943 100644
--- a/src/java/com/android/internal/telephony/sip/SipPhone.java
+++ b/src/java/com/android/internal/telephony/sip/SipPhone.java
@@ -64,7 +64,7 @@ public class SipPhone extends SipPhoneBase {
     private SipManager mSipManager;
     private SipProfile mProfile;
 
-    SipPhone (Context context, PhoneNotifier notifier, SipProfile profile) {
+    public SipPhone (Context context, PhoneNotifier notifier, SipProfile profile) {
         super("SIP:" + profile.getUriString(), context, notifier);
 
         if (DBG) log("new SipPhone: " + profile.getUriString());
diff --git a/src/java/com/android/internal/telephony/sip/SipPhoneFactory.java b/src/java/com/android/internal/telephony/sip/SipPhoneFactory.java
index 3383bed..ca4559b 100644
--- a/src/java/com/android/internal/telephony/sip/SipPhoneFactory.java
+++ b/src/java/com/android/internal/telephony/sip/SipPhoneFactory.java
@@ -16,6 +16,10 @@
 
 package com.android.internal.telephony.sip;
 
+// BEGIN privacy additions
+import android.privacy.surrogate.PrivacySipPhone;
+//END privacy
+
 import com.android.internal.telephony.PhoneNotifier;
 
 import android.content.Context;
@@ -40,7 +44,7 @@ public class SipPhoneFactory {
             PhoneNotifier phoneNotifier) {
         try {
             SipProfile profile = new SipProfile.Builder(sipUri).build();
-            return new SipPhone(context, phoneNotifier, profile);
+            return new PrivacySipPhone(context, phoneNotifier, profile);
         } catch (ParseException e) {
             Rlog.w("SipPhoneFactory", "makePhone", e);
             return null;
